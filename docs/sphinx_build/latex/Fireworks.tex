%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
\edef\sphinxdqmaybe{\ifdefined\DeclareUnicodeCharacterAsOptional\string"\fi}
  \DeclareUnicodeCharacter{\sphinxdqmaybe00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{2}



\title{Fireworks Documentation}
\date{Jan 24, 2019}
\release{0.2.8}
\author{Saad Khan}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\maketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}
\noindent{\hspace*{\fill}\sphinxincludegraphics{{fireworks}.jpg}\hspace*{\fill}}



Tensor algebra frameworks such as TensorFlow and PyTorch have made developing neural network based machine learning models surprisingly easy in the past few years. The flowgraph architecture that these frameworks are built around makes it simple to apply algebraic transforms such as gradients to tensor valued datasets with GPU optimization, such as in neural networks.

While these frameworks offer building blocks for constructing models, we often want tools to combine those blocks in reusable manners. Libraries such as Keras and Gluon are built on top of these computation frameworks to offer abstractions specific to certain types of neural networks that can be stacked together in layers. The Ignite library for pytorch takes a more hands-on approach. It provides an ‘engine’ class that has event methods corresponding to the stages of a machine learning training process (before training, before epoch, before step, during step, after step, etc.). The developer writes functions for what should happen during each of these events (what happens during a training step, at the end of an epoch, etc.), and the engine then makes sure those functions are called at the correct times. On the other extreme, there are completely hands-off machine learning frameworks such as arya.ai and Google autoML that allow one to drag and drop elements and data to construct and train a neural network model.

Which of these approaches makes the most sense? For a researcher, control and flexibility are of paramount importance. Models should be easy to construct but allow one to step in wherever additional control is needed. This is particularly important because in research, one often wants to design models that cannot be expressed using simpler frameworks. For this reason, I prefer the combination of PyTorch + Ignite for deep learning.

However, these tools do not satisfy all of the needs of a deep learning pipeline. A pain point in all deep learning frameworks is data entry; one has to take data in its original form and morph it into the form that the model expects (tensors, TFRecords, etc.). This process can include acquiring the data from a database or an API call, formatting it, applying preprocessing transforms such as mapping text to vectors based on a vocabulary, and preparing mini batches for training. In each of these steps, one must be cognizant of memory, storage, bandwidth, and compute limitations. For example, if a dataset is too big to fit in memory, then it’s journey must be streamed or broken into chunks. In practice, dealing with these issues takes more time than developing the actual models. Hence, we are in a strange position where it’s easy to construct a bidirectional LSTM RNN with attention, but it’s hard to load in a corpus of text from a database to train a classifier with that RNN.

This is where Fireworks comes in. Fireworks is a python-first framework for performing the data processing steps of machine learning in a modular and reusable manner. It does this by moving data between objects called ‘Sources’. A Source can represent a file, a database, or a transform. Each Source has a set of input Sources and is itself an input to other Sources, and as data flows from Source to Source, transforms are applied one at a time, creating a graph of data flow. Because each Source is independent, they can be stacked and reused in the future. Moreover, because Sources are aware of their inputs, they can also call methods on their inputs, and this enables lazy evaluation of data transformations. Lastly, the means of communication between Sources is represented by a Message object. A Message is essentially a (python) dict of arrays, lists, vectors, tensors, etc. It generalizes the functionality of a pandas dataframe to include the ability to store pytorch tensors. This makes it easy to adapt traditional ML pipelines that use pandas and sklearn, because Messages behave like dataframes. As a result, Fireworks is useful for any data processing task, not just deep learning. It can be used for interacting with a database, constructing financial models with pandas, and so much more.


\chapter{Overview}
\label{\detokenize{index:overview}}
Fireworks consists of a number of modules that are designed to work together to facilitate an aspect of deep learning and data processing.

\sphinxstylestrong{Message}
\begin{quote}

“A dictionary of vectors and tensors”. This class standardizes the means of communication between sources. Standardizing the means of communication makes it easier to write models that are reusable, because the inputs and outputs are always the same format.
\end{quote}

\sphinxstylestrong{Source}

A Class that abstracts data access and transformation. Sources can be linked together to form a graph, allowing one to modularly construct a data pipeline.

\sphinxstylestrong{MessageCache}

This class addresses the particular challenge of dealing with datasets that won’t fit in memory. A MessageCache behaves like a python cache that supports insertions, deletions, and accessions, except the underlying data structure is a message. This enables one to hold a portion of a larger dataset in memory  while virtually representing the entire dataset as a message.

\sphinxstylestrong{Hyperparameter Optimization}

This module takes an approach similar to Ignite, except for hyperparameter optimization. It provides a class called Factory that has methods corresponding to the events in a hyperparameter training process (train, evaluate, decide on new parameters, etc.) that can be provided by the developer. In addition, training runs are treated as independent processes, enabling one to spawn multiple training runs simultaneously to evaluate multiple hyperparameters at once.

\sphinxstylestrong{Relational Database Integration}

Fireworks.database has Sources that can read from and write to a database in the middle of a pipeline. Because it is based on python SQLalchemy library, it can be used to incorporate almost any relational database into a data analysis workflow.
Collecting and Storing Experimental Runs / Metrics
In order to make machine learning research reproducible, we have to be able to store metadata and outputs associated with experiments. This module implements an Experiment class that creates a folder and can generate file handles and SQLite tables residing in that folder to save information to. It can also store user defined metadata, all in a given experiment’s folder. This folder can be reloaded at any time in order to access the results of that experiment, regenerate plots, perform additional analyses, and so on.

\sphinxstylestrong{Not Yet Implemented / Roadmap Objectives}

(An experiment is a single run of get data - preprocess - train - evaluate - hyperparams - test)

\sphinxstylestrong{Plotting}

Generating plots is the primary means for analyzing and communicating the results of an experiment. We want to generate plots in such a way that we can go back later on and change the formatting (color scheme, etc.) or generate new plots from the data. In order to do this, plots must be generated dynamically rather than as static images. In addition, we want to create a robust means for displaying plots using a dashboard framework such as Plotly Dash. Tools such as Visdom are great for displaying live metrics from an experiment, but they are not designed to present hundreds of plots at once or to display those plots in a pleasing manner (such as with dropdown menus).
My goal is to create a dashboard that can display all information associated with a chosen experiment. It should include an SQLite browser, a plotly dashboard, a Visdom instance, and a Tensorboard instance. This should allow one to have all of the common visualization tools for machine learning in a single place.

\sphinxstylestrong{Dry Runs}

Certain steps in a data processing pipeline can be time consuming one-time operations that make it annoying to repeatedly start an experiment over. We want to set up means to ‘dry run’ an experiment in order to identify and fix bugs before running it on the full dataset. Additionally, we want to be able to set up checkpoints that enable one to continue an experiment after pausing it or loading it from a database.

\sphinxstylestrong{Distributed and Parallel Data Processing}

The idea of representing the data processing pipeline as a graph can naturally scale to parallel and distributed environments. In order to do make this happen, we need to write a scheduler that can call methods on Sources in parallel and add support for asynchronous method calls on Sources. For distributed processing, we have to write a tool for containerizing Sources and having them communicate over a container orchestration framework. Argo is a framework for Kubernetes we can use that is designed for this task.

\sphinxstylestrong{True Graph-based Pipelines}

Fireworks at present only supports DAG shaped pipelines rooted at the end. This means that while multiple sources can feed into one source, feeding one source into multiple output sources does not do anything useful. Loops and branches would break everything, because there is no code for handling those scenarios right now. Additionally, Sources are only aware of their inputs, not their outputs. While this simplifies the framework, it only enables communication in one direction.

\sphinxstylestrong{Dynamic Optimization of Data Pipeline}

Many sources have to occasionally perform time consuming O(1) tasks (such as precomputing indices corresponding to minibatches). Ideally, these tasks should be performed asynchronously, and the timing of when to perform them should be communicated by downstream sources. Adding the ability to communicate such timings would allow the pipeline to dynamically optimize itself in creative ways. For example, a CachingSource could prefetch elements into its cache that are expected to be called in the future to speed up its operation.

\sphinxstylestrong{Static Performance Optimization}

Right now, the focus is on establishing the interface and abstractions associated with Fireworks. There are many places where operations can be optimized using better algorithms, cython implementations of important code sections, and eliminating redundant code.


\chapter{Contents}
\label{\detokenize{index:contents}}

\section{Project}
\label{\detokenize{Project:project}}\label{\detokenize{Project::doc}}

\subsection{History}
\label{\detokenize{Project:history}}
Saad Khan began working on Fireworks in June 2018. It was open sourced in October 2018.


\subsection{Committers}
\label{\detokenize{Project:committers}}\begin{itemize}
\item {} 
@smk508 (Saad Khan)

\end{itemize}


\subsection{Resources}
\label{\detokenize{Project:resources}}\begin{itemize}
\item {} 
\sphinxhref{https://pytorch.org/}{PyTorch}

\item {} 
\sphinxhref{https://pytorch.org/ignite/}{Ignite}

\end{itemize}


\subsection{Roadmap}
\label{\detokenize{Project:roadmap}}\begin{itemize}
\item {} 
Add examples and flesh out documentation

\item {} 
Full test coverage

\item {} 
Performance improvements

\item {} 
Parallel/asynchronous execution support

\end{itemize}


\section{License}
\label{\detokenize{License:license}}\label{\detokenize{License::doc}}
Copyright 2019 Saad Khan

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


\section{Installation}
\label{\detokenize{Installation:installation}}\label{\detokenize{Installation::doc}}

\subsection{Install from PyPi}
\label{\detokenize{Installation:install-from-pypi}}
You will be able to install Fireworks using pip (Note: this doesn’t work yet.):

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{install} \PYG{n}{pytorch}\PYG{o}{\PYGZhy{}}\PYG{n}{fireworks}
\end{sphinxVerbatim}

It is recommended to do this from within a virtual environment.


\subsection{Install from source}
\label{\detokenize{Installation:install-from-source}}
For development purposes, you can download the source repository and install the latest version directly.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{git} \PYG{n}{clone} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{smk508}\PYG{o}{/}\PYG{n}{Fireworks}\PYG{o}{.}\PYG{n}{git}
\PYG{n}{cd} \PYG{n}{Fireworks}
\PYG{n}{pip} \PYG{n}{install} \PYG{o}{.}
\end{sphinxVerbatim}


\section{Tutorial}
\label{\detokenize{Tutorial:tutorial}}\label{\detokenize{Tutorial::doc}}

\subsection{Basic Operations}
\label{\detokenize{Tutorial:basic-operations}}

\subsection{Chaining Sources}
\label{\detokenize{Tutorial:chaining-sources}}

\subsection{Using Databases}
\label{\detokenize{Tutorial:using-databases}}

\subsection{Using Experiments}
\label{\detokenize{Tutorial:using-experiments}}

\subsection{Hyperparameter Optimization}
\label{\detokenize{Tutorial:hyperparameter-optimization}}

\section{API Reference}
\label{\detokenize{Fireworks:module-Fireworks}}\label{\detokenize{Fireworks:api-reference}}\label{\detokenize{Fireworks::doc}}\index{Fireworks (module)}

\subsection{Messages}
\label{\detokenize{Fireworks:messages}}
Most data processing workflows have the same basic architecture and only differ in the type of data and how those inputs are formatted. Minor differences in this formatting can make almost identical code non-reusable. To address this issue, this framework insists on using a single data structure to pass information between components - the Message object.
A Message consists of two components: a Pandas DataFrame and a TensorMessage. The former is a very general purpose structure that benefits from all of the features of the popular Pandas library - a DataFrame is essentially a dictionary of arrays. However, in the context of pytorch deep learning, we cannot use DataFrames for everything because we cannot store tensor objects inside a dataframe (Pandas breaks down tensors into unit sized tensors and stores those units as objects as opposed to storing them as one entity). The TensorMessage emulates the structure and methods of DataFrames, except it only stores pytorch tensors (in the future, tensor’s in other frameworks could be supported). Because of this, it also attempts to autoconvert inputs to tensors. With this combined structure, one could store metadata in the dataframe and example/label pairs in the TensorMessage.

\phantomsection\label{\detokenize{Fireworks:module-Fireworks.core.message}}\index{Fireworks.core.message (module)}\index{Message (class in Fireworks.core.message)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.Message}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.core.message.}}\sphinxbfcode{\sphinxupquote{Message}}}{\emph{*args}, \emph{metadata=None}, \emph{length=None}, \emph{**kwargs}}{}
Bases: \sphinxhref{https://docs.python.org/3/library/functions.html\#object}{\sphinxcode{\sphinxupquote{object}}}

A Message is a class for representing data in a way that can be consumed by different analysis pipelines in python. It does this by
representing the data as a dictionary of arrays. This is the same approach that pandas takes, but Messages are specifically designed to
be used with pytorch, in which the core data structure is a tensor, which cannot be mixed into a pandas dataframe.
Hence, a Message has two elements: a TensorMessage which specifically stores tensor objects and a dataframe which can be used for handling
any other type of array data. With this structure, you could put your training data in as a TensorMessage and any associated metadata as
the df and lump all of that into a message. All of the existing df methods can be run on the metadata, and any pytorch operations can be
performed on the tensor part.

Messages support operations such as appending one message to another, joining two messages along keys, applying maps to the message’s values,
and equality checks.

Additionally, messages behave as much as possible like dicts. In many scenarios, a dict will be able to substitute for a message and vice-versa.
For example, for preparing batches to feed into an RNN to classify DNA sequences, one could create a Message like this:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{my\PYGZus{}message} \PYG{o}{=} \PYG{n}{Message}\PYG{p}{(}\PYG{p}{\PYGZob{}}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{embedded\PYGZus{}sequences}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{Tensor}\PYG{p}{(}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{labels}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{LongTensor}\PYG{p}{(}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{raw\PYGZus{}sequences}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TCGA...}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}\PYG{p}{]}\PYG{p}{,}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\end{sphinxVerbatim}

The Message constructor will parse this dictionary and store the labels and embedded sequences inside a TensorMessage and the raw\_sequences and other metadata in the dataframe.

Now we can access elements of this Message:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{my\PYGZus{}message}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{my\PYGZus{}message}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{l+m+mi}{10}\PYG{p}{]}
\PYG{n}{my\PYGZus{}message}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{labels}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{my\PYGZus{}message}\PYG{p}{)}
\end{sphinxVerbatim}

We can also move tensors to the GPU and back:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{my\PYGZus{}message}\PYG{o}{.}\PYG{n}{cpu}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{my\PYGZus{}message}\PYG{o}{.}\PYG{n}{cuda}\PYG{p}{(}\PYG{n}{device\PYGZus{}num}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Defaults to 0 for device number}
\PYG{n}{my\PYGZus{}message}\PYG{o}{.}\PYG{n}{cuda}\PYG{p}{(}\PYG{n}{keys}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{labels}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Can specify only certain columns to move if desired}
\end{sphinxVerbatim}
\index{check\_length() (Fireworks.core.message.Message method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.Message.check_length}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_length}}}{}{}
Checks that lengths of the internal tensor\_message and dataframe are the same and equalto self.len
If one of the two is empty (length 0) then, that is fine.

\end{fulllineitems}

\index{columns (Fireworks.core.message.Message attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.Message.columns}}\pysigline{\sphinxbfcode{\sphinxupquote{columns}}}
Returns names of tensors in TensorMessage

\end{fulllineitems}

\index{keys() (Fireworks.core.message.Message method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.Message.keys}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{keys}}}{}{}
Returns names of tensors in TensorMessage
Note: This is the same as self.columns

\end{fulllineitems}

\index{index (Fireworks.core.message.Message attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.Message.index}}\pysigline{\sphinxbfcode{\sphinxupquote{index}}}
Returns index for internal tensors

\end{fulllineitems}

\index{append() (Fireworks.core.message.Message method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.Message.append}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{append}}}{\emph{other}}{}
Compines messages together.
Should initialize other if not a message already.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{other}} \textendash{} The message to append to self. Must have the same keys as self so that in the resulting Message,
every column continues to have the same length as needed.

\end{description}\end{quote}

\end{fulllineitems}

\index{merge() (Fireworks.core.message.Message method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.Message.merge}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{merge}}}{\emph{other}}{}
Combines messages horizontally by producing a message with the keys/values of both.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{other}} \textendash{} 
The message to merge with self. Must have different keys and the same length as self to ensure length consistencies.
Alternatively, if either self or other have an empty TensorMessage or df, then they can be merged together safely as long
as the resulting Message has a consistent length.
For example:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{message\PYGZus{}a} \PYG{o}{=} \PYG{n}{Message}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} This is essentially a DataFrame}
\PYG{n}{message\PYGZus{}b} \PYG{o}{=} \PYG{n}{Message}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{Tensor}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} This is essentially a TensorMessage}
\PYG{n}{message\PYGZus{}c} \PYG{o}{=} \PYG{n}{Message\PYGZus{}a}\PYG{o}{.}\PYG{n}{merge}\PYG{p}{(}\PYG{n}{message\PYGZus{}b}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} This works}
\end{sphinxVerbatim}


\item[{Returns}] \leavevmode
The concatenated Message containing columns from self and other.

\item[{Return type}] \leavevmode
message

\end{description}\end{quote}

\end{fulllineitems}

\index{map() (Fireworks.core.message.Message method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.Message.map}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{map}}}{\emph{mapping}}{}
Applies function mapping to message. If mapping is a dict, then maps will be applied to the correspondign keys as columns, leaving
columns not present in mapping untouched.
In otherwords, mapping would be a dict of column\_name:functions specifying the mappings.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{mapping}} \textendash{} Can either be a dict mapping column names to functions that should be applied to those columns, or a single function.
In the latter case, the mapping function will be applied to every column.

\item[{Returns}] \leavevmode
A Message with the column:value pairs produced by the mapping.

\item[{Return type}] \leavevmode
message

\end{description}\end{quote}

\end{fulllineitems}

\index{tensors() (Fireworks.core.message.Message method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.Message.tensors}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{tensors}}}{\emph{keys=None}}{}
Return tensors associated with message as a tensormessage.
If keys are specified, returns tensors associated with those keys, performing conversions as needed.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{keys}} \textendash{} Keys to get. Default = None, in which case all tensors are returned as a TensorMessage.
If columns corresponding to requested keys are not tensors, they will be converted.

\item[{Returns}] \leavevmode
A TensorMessage containing the tensors requested.

\item[{Return type}] \leavevmode
tensors ({\hyperref[\detokenize{Fireworks:Fireworks.core.message.TensorMessage}]{\sphinxcrossref{TensorMessage}}})

\end{description}\end{quote}

\end{fulllineitems}

\index{dataframe() (Fireworks.core.message.Message method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.Message.dataframe}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dataframe}}}{\emph{keys=None}}{}
Returns message as a dataframe. If keys are specified, only returns those keys as a dataframe.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{keys}} \textendash{} Keys to get. Default = None, in which case all non-tensors are returned as a DataFrame.
If columns corresponding to requested keys are tensors, they will be converted (to np.arrays).

\item[{Returns}] \leavevmode
A DataFrame containing the columns requested.

\item[{Return type}] \leavevmode
df (pd.DataFrame)

\end{description}\end{quote}

\end{fulllineitems}

\index{to\_dataframe() (Fireworks.core.message.Message method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.Message.to_dataframe}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{to\_dataframe}}}{\emph{keys=None}}{}
Returns message with columns indicated by keys converted to DataFrame. If keys is None, all tensors are converted.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{keys}} \textendash{} Keys to get. Default = None, in which case all tensors are mapped to DataFrame.

\item[{Returns}] \leavevmode
A Message in which the desired columns are DataFrames.

\item[{Return type}] \leavevmode
message

\end{description}\end{quote}

\end{fulllineitems}

\index{to\_tensors() (Fireworks.core.message.Message method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.Message.to_tensors}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{to\_tensors}}}{\emph{keys=None}}{}
Returns message with columns indicated by keys converted to Tensors. If keys is None, all columns are converted.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{keys}} \textendash{} Keys to get. Default = None, in which case all columns are mapped to Tensor.

\item[{Returns}] \leavevmode
A Message in which the desired columns are Tensors.

\item[{Return type}] \leavevmode
message

\end{description}\end{quote}

\end{fulllineitems}

\index{permute() (Fireworks.core.message.Message method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.Message.permute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{permute}}}{\emph{index}}{}
Reorders elements of message based on index.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{index}} \textendash{} A valid index for the message.

\item[{Returns}] \leavevmode
\begin{description}
\item[{A new Message with the elements arranged according to the input index.}] \leavevmode
For example,
::
message\_a = Message(\{‘a’:{[}1,2,3{]}\})
message\_b = message\_a.permute({[}2,1,0{]})
message\_c = Message(\{‘a’: {[}3,2,1{]}\})
message\_b == message\_c

The last statement will evaluate to True

\end{description}


\item[{Return type}] \leavevmode
message

\end{description}\end{quote}

\end{fulllineitems}

\index{cpu() (Fireworks.core.message.Message method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.Message.cpu}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{cpu}}}{\emph{keys=None}}{}
Moves tensors to system memory. Can specify which ones to move by specifying keys.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{keys}} \textendash{} Keys to move to system memory. Default = None, meaning all columns are moved.

\item[{Returns}] \leavevmode
Moved message

\item[{Return type}] \leavevmode
message ({\hyperref[\detokenize{Fireworks:Fireworks.core.message.Message}]{\sphinxcrossref{Message}}})

\end{description}\end{quote}

\end{fulllineitems}

\index{cuda() (Fireworks.core.message.Message method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.Message.cuda}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{cuda}}}{\emph{device=0}, \emph{keys=None}}{}
Moves tensors to gpu with given device number. Can specify which ones to move by specifying keys.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{device}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} CUDA device number to use. Default = 0.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{keys}} \textendash{} Keys to move to GPU. Default = None, meaning all columns are moved.

\end{itemize}

\item[{Returns}] \leavevmode
Moved message

\item[{Return type}] \leavevmode
message ({\hyperref[\detokenize{Fireworks:Fireworks.core.message.Message}]{\sphinxcrossref{Message}}})

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{TensorMessage (class in Fireworks.core.message)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.TensorMessage}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.core.message.}}\sphinxbfcode{\sphinxupquote{TensorMessage}}}{\emph{message\_dict=None}, \emph{map\_dict=None}}{}
Bases: \sphinxhref{https://docs.python.org/3/library/functions.html\#object}{\sphinxcode{\sphinxupquote{object}}}

A TensorMessage is a class for representing data meant for consumption by pytorch as a dictionary of tensors.
\index{keys() (Fireworks.core.message.TensorMessage method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.TensorMessage.keys}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{keys}}}{\emph{*args}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{columns (Fireworks.core.message.TensorMessage attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.TensorMessage.columns}}\pysigline{\sphinxbfcode{\sphinxupquote{columns}}}
Returns names of tensors in TensorMessage

\end{fulllineitems}

\index{index (Fireworks.core.message.TensorMessage attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.TensorMessage.index}}\pysigline{\sphinxbfcode{\sphinxupquote{index}}}
Returns index for internal tensors

\end{fulllineitems}

\index{append() (Fireworks.core.message.TensorMessage method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.TensorMessage.append}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{append}}}{\emph{other}}{}
Note if the target message has additional keys, those will be dropped.
The target message must also have every key present in this message in
order to avoid an value error due to length differences.

\end{fulllineitems}

\index{merge() (Fireworks.core.message.TensorMessage method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.TensorMessage.merge}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{merge}}}{\emph{other}}{}
Combines self with other into a message with the keys of both.
self and other must have distinct keys.

\end{fulllineitems}

\index{permute() (Fireworks.core.message.TensorMessage method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.TensorMessage.permute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{permute}}}{\emph{index}}{}
Rearranges elements of TensorMessage to align with new index.

\end{fulllineitems}

\index{cuda() (Fireworks.core.message.TensorMessage method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.TensorMessage.cuda}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{cuda}}}{\emph{device=0}, \emph{keys=None}}{}
Moves all tensors in TensorMessage to cuda device specified by device number. Specify keys to limit the transformation
to specific keys only.

\end{fulllineitems}

\index{cpu() (Fireworks.core.message.TensorMessage method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.TensorMessage.cpu}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{cpu}}}{\emph{keys=None}}{}
Moves all tensors in TensorMessage to cpu. Specify keys to limit the transformation
to specific keys only.

\end{fulllineitems}


\end{fulllineitems}

\index{compute\_length() (in module Fireworks.core.message)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.compute_length}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.core.message.}}\sphinxbfcode{\sphinxupquote{compute\_length}}}{\emph{of\_this}}{}
Of\_this is a dict of listlikes. This function computes the length of that object, which is the length of all of the listlikes, which
are assumed to be equal. This also implicitly checks for the lengths to be equal, which is necessary for Message/TensorMessage.

\end{fulllineitems}

\index{extract\_tensors() (in module Fireworks.core.message)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.extract_tensors}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.core.message.}}\sphinxbfcode{\sphinxupquote{extract\_tensors}}}{\emph{from\_this}}{}
Given a dict from\_this, returns two dicts, one containing all of the key/value pairs corresponding to tensors in from\_this, and the other
containing the remaining pairs.

\end{fulllineitems}

\index{slice\_to\_list() (in module Fireworks.core.message)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.slice_to_list}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.core.message.}}\sphinxbfcode{\sphinxupquote{slice\_to\_list}}}{\emph{s}}{}
Converts a slice object to a list of indices

\end{fulllineitems}

\index{complement() (in module Fireworks.core.message)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.complement}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.core.message.}}\sphinxbfcode{\sphinxupquote{complement}}}{\emph{indices}, \emph{n}}{}
Given an index, returns all indices between 0 and n that are not in the index.

\end{fulllineitems}

\index{cat() (in module Fireworks.core.message)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.cat}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.core.message.}}\sphinxbfcode{\sphinxupquote{cat}}}{\emph{list\_of\_args}}{}
Concatenates messages in list\_of\_args into one message.

\end{fulllineitems}

\index{merge() (in module Fireworks.core.message)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.message.merge}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.core.message.}}\sphinxbfcode{\sphinxupquote{merge}}}{\emph{list\_of\_args}}{}
Merges messages in list\_of\_args into one message with all the keys combined.

\end{fulllineitems}



\subsection{Pipes}
\label{\detokenize{Fireworks:pipes}}
With a uniform data structure for information transfer established, we can create functions and classes that are reusable because of the standardized I/O expectations. A Pipe object represents some transformation that is applied to data as it flows through a pipeline. For example, a pipeline could begin with a source that reads from the database, followed by one that cache those reads in memory, then one that applies embedding transformations to create tensors, and so on.

These transformations are represented as classes rather than functions because we sometimes want to be able to apply transformations in a just-in-time or ahead-of-time manner, or have the transformations be dependent on some upstream or downstream aspect of the pipeline. For example, the Pipe that creates minibatches for training can convert its inputs to tensors and move them to GPU as a minibatch is created, using the tensor-conversion method implemented by an upstream Pipe. Or a Pipe that caches its inputs can prefetch objects to improve overall performance, and so on.

\phantomsection\label{\detokenize{Fireworks:module-Fireworks.core.pipe}}\index{Fireworks.core.pipe (module)}\index{Pipe (class in Fireworks.core.pipe)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.pipe.Pipe}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.core.pipe.}}\sphinxbfcode{\sphinxupquote{Pipe}}}{\emph{input=None}, \emph{*args}, \emph{**kwargs}}{}
Bases: \sphinxhref{https://docs.python.org/3/library/abc.html\#abc.ABC}{\sphinxcode{\sphinxupquote{abc.ABC}}}

The core data structure in fireworks.
A Pipe can take Pipes as inputs, and its outputs can be streamed to other Pipes.
All communication is done via Message objects.
Method calls are deferred to input Pipes recursively until a Pipe that implements the method is reached.

This is made possible with a recursive function call method. Any Pipe can use this method to call a method on its inputs; this will recursively loop until reaching a Pipe that implements the method and return those outputs (as a Message) or raise an error if there are none. For example, we can do something like this:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{reader} \PYG{o}{=} \PYG{n}{pipe\PYGZus{}for\PYGZus{}reading\PYGZus{}from\PYGZus{}some\PYGZus{}dataset}\PYG{p}{(}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}
\PYG{n}{cache} \PYG{o}{=} \PYG{n}{CachingPipe}\PYG{p}{(}\PYG{n}{reader}\PYG{p}{,} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LRU}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{embedder} \PYG{o}{=} \PYG{n}{CreateEmbeddingsPipe}\PYG{p}{(}\PYG{n}{cache}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{n}{loader} \PYG{o}{=} \PYG{n}{CreateMinibatchesPipe}\PYG{p}{(}\PYG{n}{embedder}\PYG{p}{\PYGZcb{}}\PYG{p}{)}

\PYG{n}{loader}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{batch} \PYG{o+ow}{in} \PYG{n}{loader}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} Code for training}
\end{sphinxVerbatim}

Under the hood, the code for loader.\_\_next\_\_() can choose to recursively call a to\_tensor() method which is implemented by embedder. Index queries and other magic methods can also be implemented recursively, and this enables a degree of commutativity when stacking Pipes together (changing the order of Pipes is often allowed because of the pass-through nature of recursive calls).

Note that in order for this to work well, there must be some consistency among method names. If a Pipe expects ‘to\_tensor’ to convert batches to tensor format, then an upstream Pipe must have a method with that name, and this should remain consistent across projects to maintain reusability. Lastly, the format for specifying inputs to a Pipe is a dictionary of Pipes. The keys in this dictionary can provide information for the Pipe to use or be ignored completely.
\index{name (Fireworks.core.pipe.Pipe attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.pipe.Pipe.name}}\pysigline{\sphinxbfcode{\sphinxupquote{name}}\sphinxbfcode{\sphinxupquote{ = 'base\_pipe'}}}
\end{fulllineitems}

\index{recursive\_call() (Fireworks.core.pipe.Pipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.pipe.Pipe.recursive_call}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{recursive\_call}}}{\emph{attribute}, \emph{*args}, \emph{ignore\_first=True}, \emph{**kwargs}}{}
Recursively calls method/attribute on input until reaching an upstream Pipe that implements the method and
returns the response as a message (empty if response is None).
Recursive calls enable a stack of Pipes to behave as one entity; any method implemented by any component can be accessed
recursively.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{attribute}} \textendash{} The name of the attribute/method to call.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{args}} \textendash{} The arguments if this is a recursive method call.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ignore\_first}} \textendash{} If True, then ignore whether or not the target attribute is implemented by self. This can be useful if a Pipe
implements a method and wants to use an upstream call of the same method as well.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} \textendash{} The kwargs is this is a recursive method call.

\end{itemize}

\item[{Returns}] \leavevmode
A dictionary mapping the name of each input Pipe to the response that was returned.

\item[{Return type}] \leavevmode
Responses (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#dict}{dict})

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{HookedPassThroughPipe (class in Fireworks.core.pipe)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.pipe.HookedPassThroughPipe}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.core.pipe.}}\sphinxbfcode{\sphinxupquote{HookedPassThroughPipe}}}{\emph{input=None}, \emph{*args}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{Fireworks:Fireworks.core.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.core.pipe.Pipe}}}}}

This Pipe has hooks which can be implemented by subclasses to modify the behavior of
passed through calls.
\index{name (Fireworks.core.pipe.HookedPassThroughPipe attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.pipe.HookedPassThroughPipe.name}}\pysigline{\sphinxbfcode{\sphinxupquote{name}}\sphinxbfcode{\sphinxupquote{ = 'Hooked-passthrough Pipe'}}}
\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{\detokenize{Fireworks:module-Fireworks.core.cache}}\index{Fireworks.core.cache (module)}\index{MessageCache (class in Fireworks.core.cache)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.MessageCache}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.core.cache.}}\sphinxbfcode{\sphinxupquote{MessageCache}}}{\emph{max\_size}}{}
Bases: \sphinxhref{https://docs.python.org/3/library/abc.html\#abc.ABC}{\sphinxcode{\sphinxupquote{abc.ABC}}}

A message cache stores parts of a larger method and supports retrievals and
insertions based on index.
The use case for a MessageCache is for storing parts of a large dataset in memory.
The MessageCache can keep track of which elements and which indices are present
in memory at a given time and allow for updates and retrievals.
\index{insert() (Fireworks.core.cache.MessageCache method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.MessageCache.insert}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{insert}}}{\emph{index}, \emph{message}}{}
Inserts message into cache along with the desired indices.
This method should be called by \_\_setitem\_\_ as needed to perform the insertion.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{index}} \textendash{} The index to insert into. Can be an int, slice, or list of integer indices.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{message}} \textendash{} The Message to insert. Should have the same length as the provided idnex.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{delete() (Fireworks.core.cache.MessageCache method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.MessageCache.delete}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{delete}}}{\emph{index}}{}
Deletes elements in the message corresponding to index.
This method should be called by \_\_setitem\_\_ or \_\_delitem\_\_ as needed.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{index}} \textendash{} The index to insert into. Can be an int, slice, or list of integer indices.

\end{description}\end{quote}

\end{fulllineitems}

\index{sort() (Fireworks.core.cache.MessageCache method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.MessageCache.sort}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sort}}}{}{}
Rearranges internal cache indices to be in sorted order.

\end{fulllineitems}

\index{search() (Fireworks.core.cache.MessageCache method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.MessageCache.search}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{search}}}{\emph{**kwargs}}{}
\end{fulllineitems}

\index{size (Fireworks.core.cache.MessageCache attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.MessageCache.size}}\pysigline{\sphinxbfcode{\sphinxupquote{size}}}
\end{fulllineitems}


\end{fulllineitems}

\index{UnlimitedCache (class in Fireworks.core.cache)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.UnlimitedCache}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.core.cache.}}\sphinxbfcode{\sphinxupquote{UnlimitedCache}}}
Bases: {\hyperref[\detokenize{Fireworks:Fireworks.core.cache.MessageCache}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.core.cache.MessageCache}}}}}

This is a basic implementation of a MessageCache that simply appends new
elements and never clears memory internally

\end{fulllineitems}

\index{BufferedCache (class in Fireworks.core.cache)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.BufferedCache}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.core.cache.}}\sphinxbfcode{\sphinxupquote{BufferedCache}}}{\emph{max\_size}}{}
Bases: {\hyperref[\detokenize{Fireworks:Fireworks.core.cache.MessageCache}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.core.cache.MessageCache}}}}}

This implements a setitem method that assumes that when the cache is full, elements must be deleted until it is max\_size - buffer\_size
in length. The deletion method, \_free, must be implemented by a subclass.
\index{init\_buffer() (Fireworks.core.cache.BufferedCache method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.BufferedCache.init_buffer}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{init\_buffer}}}{\emph{buffer\_size=0}}{}
\end{fulllineitems}

\index{free() (Fireworks.core.cache.BufferedCache method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.BufferedCache.free}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{free}}}{\emph{n}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{RRCache (class in Fireworks.core.cache)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.RRCache}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.core.cache.}}\sphinxbfcode{\sphinxupquote{RRCache}}}{\emph{max\_size}}{}
Bases: {\hyperref[\detokenize{Fireworks:Fireworks.core.cache.BufferedCache}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.core.cache.BufferedCache}}}}}
\index{free() (Fireworks.core.cache.RRCache method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.RRCache.free}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{free}}}{\emph{n}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{RankingCache (class in Fireworks.core.cache)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.RankingCache}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.core.cache.}}\sphinxbfcode{\sphinxupquote{RankingCache}}}{\emph{max\_size}}{}
Bases: {\hyperref[\detokenize{Fireworks:Fireworks.core.cache.MessageCache}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.core.cache.MessageCache}}}}}

Implements a free method that deletes elements based on a ranking function.
\index{init\_rank\_dict() (Fireworks.core.cache.RankingCache method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.RankingCache.init_rank_dict}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{init\_rank\_dict}}}{}{}
\end{fulllineitems}

\index{free() (Fireworks.core.cache.RankingCache method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.RankingCache.free}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{free}}}{\emph{n}, \emph{x=0}}{}
\end{fulllineitems}

\index{on\_update\_existing() (Fireworks.core.cache.RankingCache method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.RankingCache.on_update_existing}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_update\_existing}}}{\emph{index}, \emph{message}}{}
\end{fulllineitems}

\index{on\_add\_new() (Fireworks.core.cache.RankingCache method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.RankingCache.on_add_new}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_add\_new}}}{\emph{index}, \emph{message}}{}
\end{fulllineitems}

\index{on\_delete() (Fireworks.core.cache.RankingCache method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.RankingCache.on_delete}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_delete}}}{\emph{index}}{}
\end{fulllineitems}

\index{on\_getitem() (Fireworks.core.cache.RankingCache method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.RankingCache.on_getitem}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_getitem}}}{\emph{index}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{LRUCache (class in Fireworks.core.cache)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.LRUCache}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.core.cache.}}\sphinxbfcode{\sphinxupquote{LRUCache}}}{\emph{*args}, \emph{buffer\_size=0}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{Fireworks:Fireworks.core.cache.RankingCache}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.core.cache.RankingCache}}}}}, {\hyperref[\detokenize{Fireworks:Fireworks.core.cache.BufferedCache}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.core.cache.BufferedCache}}}}}

Implements a Least Recently Used cache. Items are deleted in descending order of how recently they were accessed.
A call to \_\_getitem\_\_ or \_\_setitem\_\_ counts as accessing an element.
\index{update\_rank() (Fireworks.core.cache.LRUCache method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.LRUCache.update_rank}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update\_rank}}}{\emph{index}}{}
\end{fulllineitems}

\index{on\_update\_existing() (Fireworks.core.cache.LRUCache method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.LRUCache.on_update_existing}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_update\_existing}}}{\emph{index}, \emph{message}}{}
\end{fulllineitems}

\index{on\_add\_new() (Fireworks.core.cache.LRUCache method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.LRUCache.on_add_new}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_add\_new}}}{\emph{index}, \emph{message}}{}
\end{fulllineitems}

\index{on\_delete() (Fireworks.core.cache.LRUCache method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.LRUCache.on_delete}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_delete}}}{\emph{index}}{}
\end{fulllineitems}

\index{on\_getitem() (Fireworks.core.cache.LRUCache method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.LRUCache.on_getitem}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_getitem}}}{\emph{index}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{LFUCache (class in Fireworks.core.cache)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.LFUCache}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.core.cache.}}\sphinxbfcode{\sphinxupquote{LFUCache}}}{\emph{*args}, \emph{buffer\_size=0}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{Fireworks:Fireworks.core.cache.RankingCache}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.core.cache.RankingCache}}}}}, {\hyperref[\detokenize{Fireworks:Fireworks.core.cache.BufferedCache}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.core.cache.BufferedCache}}}}}

Implements a Least Frequently Used cache. Items are deleted in increasing order of how frequently they are accessed.
A call to \_\_getitem\_\_ or \_\_setitem\_\_ counts as accessing an element.
\index{update\_rank() (Fireworks.core.cache.LFUCache method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.LFUCache.update_rank}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update\_rank}}}{\emph{index}}{}
\end{fulllineitems}

\index{on\_update\_existing() (Fireworks.core.cache.LFUCache method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.LFUCache.on_update_existing}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_update\_existing}}}{\emph{index}, \emph{message}}{}
\end{fulllineitems}

\index{on\_add\_new() (Fireworks.core.cache.LFUCache method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.LFUCache.on_add_new}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_add\_new}}}{\emph{index}, \emph{message}}{}
\end{fulllineitems}

\index{on\_delete() (Fireworks.core.cache.LFUCache method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.LFUCache.on_delete}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_delete}}}{\emph{index}}{}
\end{fulllineitems}

\index{on\_getitem() (Fireworks.core.cache.LFUCache method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.LFUCache.on_getitem}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_getitem}}}{\emph{index}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{pointer\_adjustment\_function() (in module Fireworks.core.cache)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.pointer_adjustment_function}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.core.cache.}}\sphinxbfcode{\sphinxupquote{pointer\_adjustment\_function}}}{\emph{index}}{}
Given an index, returns a function that that takes an integer as input and returns how many elements of the index the number is greater than.
This is used for readjusting pointers after a deletion. For example, if you delete index 2, then every index greater than 2 must slide down 1
but index 0 and 1 do not more.

\end{fulllineitems}

\index{index\_to\_list() (in module Fireworks.core.cache)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.index_to_list}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.core.cache.}}\sphinxbfcode{\sphinxupquote{index\_to\_list}}}{\emph{index}}{}
Converts an index to a list.

\end{fulllineitems}

\index{slice\_to\_list() (in module Fireworks.core.cache)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.slice_to_list}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.core.cache.}}\sphinxbfcode{\sphinxupquote{slice\_to\_list}}}{\emph{s}}{}
Converts a slice object to a list of indices

\end{fulllineitems}

\index{get\_indices() (in module Fireworks.core.cache)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.cache.get_indices}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.core.cache.}}\sphinxbfcode{\sphinxupquote{get\_indices}}}{\emph{values}, \emph{listlike}}{}
Returns the indices in litlike that match elements in values

\end{fulllineitems}

\phantomsection\label{\detokenize{Fireworks:module-Fireworks.toolbox.pipes}}\index{Fireworks.toolbox.pipes (module)}\index{BioSeqPipe (class in Fireworks.toolbox.pipes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.pipes.BioSeqPipe}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.toolbox.pipes.}}\sphinxbfcode{\sphinxupquote{BioSeqPipe}}}{\emph{path}, \emph{input=None}, \emph{filetype='fasta'}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{Fireworks:Fireworks.core.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.core.pipe.Pipe}}}}}

Class for representing biosequence data.
Specifically, this class can read biological data files (such as fasta) and iterate throug them as a Pipe.
This can serve as the first Pipe in a pipeline for analyzing genomic data.
\index{name (Fireworks.toolbox.pipes.BioSeqPipe attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.pipes.BioSeqPipe.name}}\pysigline{\sphinxbfcode{\sphinxupquote{name}}\sphinxbfcode{\sphinxupquote{ = 'BioSeqPipe'}}}
\end{fulllineitems}

\index{reset() (Fireworks.toolbox.pipes.BioSeqPipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.pipes.BioSeqPipe.reset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset}}}{}{}
Resets the iterator to the beginning of the file. Specifically, it calls SeqIO.parse again as if reinstantiating the object.

\end{fulllineitems}


\end{fulllineitems}

\index{LoopingPipe (class in Fireworks.toolbox.pipes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.pipes.LoopingPipe}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.toolbox.pipes.}}\sphinxbfcode{\sphinxupquote{LoopingPipe}}}{\emph{input}, \emph{*args}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{Fireworks:Fireworks.core.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.core.pipe.Pipe}}}}}

This Pipe can take any iterator and make it appear to be indexable by iterating through the input
as needed to reach any given index.

The input Pipe must implement \_\_next\_\_ and reset (to be repeatable),
and this will simulate \_\_getitem\_\_ by repeatedly looping through the iterator as needed.

For example, say we have a Pipe that iterates through the lines of a FASTA file:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fasta} \PYG{o}{=} \PYG{n}{BioSeqPipe}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{genes.fasta}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

This Pipe can only iterate through the file in one direciton. If we want to access arbitrary elements,
we can do this:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{clock} \PYG{o}{=} \PYG{n}{LoopingPipe}\PYG{p}{(}\PYG{n}{inputs}\PYG{o}{=}\PYG{n}{fasta}\PYG{p}{)}
\PYG{n}{clock}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}
\PYG{n}{clock}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{]}
\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{clock}\PYG{p}{)}
\end{sphinxVerbatim}

All of these actions are now possible. Note that this is in general an expensive process, because the Pipe
has to iterate one at a time to get to the index it needs. In practice, this Pipe should pipe its output
to a CachingPipe that can store values in memory. This approach enables you to process datasets that don’t
entirely fit in memory; you can stream in what you need and cache portions. From the perspective of the downstream
Pipes, every element of the dataset is accessible as if it were in memory.
\index{name (Fireworks.toolbox.pipes.LoopingPipe attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.pipes.LoopingPipe.name}}\pysigline{\sphinxbfcode{\sphinxupquote{name}}\sphinxbfcode{\sphinxupquote{ = 'LoopingPipe'}}}
\end{fulllineitems}

\index{check\_input() (Fireworks.toolbox.pipes.LoopingPipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.pipes.LoopingPipe.check_input}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_input}}}{}{}
Checks input to determine if it implements \_\_next\_\_ and reset methods.

\end{fulllineitems}

\index{reset() (Fireworks.toolbox.pipes.LoopingPipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.pipes.LoopingPipe.reset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset}}}{}{}
Calls reset on input Pipes and sets position to 0.

\end{fulllineitems}

\index{compute\_length() (Fireworks.toolbox.pipes.LoopingPipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.pipes.LoopingPipe.compute_length}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_length}}}{}{}
Step forward as far as the inputs will allow and compute length.

Length is also calculated implicitly as items are accessed.

Note: If the inputs are infinite, then this will go on forever.

\end{fulllineitems}

\index{step\_forward() (Fireworks.toolbox.pipes.LoopingPipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.pipes.LoopingPipe.step_forward}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{step\_forward}}}{\emph{n}}{}
Steps forward through inputs until position = n and then returns that value.

This also updates the internal length variable if the iterator ends due to this method call.

\end{fulllineitems}


\end{fulllineitems}

\index{CachingPipe (class in Fireworks.toolbox.pipes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.pipes.CachingPipe}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.toolbox.pipes.}}\sphinxbfcode{\sphinxupquote{CachingPipe}}}{\emph{input}, \emph{*args}, \emph{cache\_size=100}, \emph{buffer\_size=0}, \emph{cache\_type='LRU'}, \emph{infinite=False}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{Fireworks:Fireworks.core.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.core.pipe.Pipe}}}}}

This Pipe can be used to dynamically cache elements from upstream Pipes.
Whenever data is requested by index, this Pipe will intercept the request and add that message alongside
the index to its internal cache.
This can be useful for dealing with datasets that don’t fit in memory or are streamed in. You can cache portions
of the dataset as you use them. By combining this with a LoopingPipe, you can create the illusion of making
the entire dataset available to downstream Pipes regardless of the type and size of the original data.

More specifically, fiven input Pipes that implement \_\_getitem\_\_, will store all calls to \_\_getitem\_\_ into
an internal cache and therafter \_\_getitem\_\_ calls will either access from the cache or trigger \_\_getitem\_\_ calls
on the input and an update to the cache.

For example,

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fasta} \PYG{o}{=} \PYG{n}{BioSeqPipe}\PYG{p}{(}\PYG{n}{path}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{genes.fasta}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{clock} \PYG{o}{=} \PYG{n}{LoopingPipe}\PYG{p}{(}\PYG{n}{inputs}\PYG{o}{=}\PYG{n}{fasta}\PYG{p}{)}
\PYG{n}{cache} \PYG{o}{=} \PYG{n}{CachingPipe}\PYG{p}{(}\PYG{n}{inputs}\PYG{o}{=}\PYG{n}{clock}\PYG{p}{,} \PYG{n}{cache\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} cache\PYGZus{}size is optional; default=100}
\end{sphinxVerbatim}

Will set up a pipeline that reads lines from a FASTA file and acessess and caches elements as requests are made

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cache}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{:}\PYG{l+m+mi}{40}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} This will be cached}
\PYG{n}{cache}\PYG{p}{[}\PYG{l+m+mi}{25}\PYG{p}{:}\PYG{l+m+mi}{30}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} This will read from the cache}
\PYG{n}{cache}\PYG{p}{[}\PYG{l+m+mi}{44}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} This will update the cache}
\PYG{n}{cache}\PYG{p}{[}\PYG{l+m+mi}{40}\PYG{p}{:}\PYG{l+m+mi}{140}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} This will fill the cache, flushing out old elements}
\PYG{n}{cache}\PYG{p}{[}\PYG{l+m+mi}{25}\PYG{p}{:}\PYG{l+m+mi}{30}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} This will read from the dataset and update the cache again}
\end{sphinxVerbatim}
\index{init\_cache() (Fireworks.toolbox.pipes.CachingPipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.pipes.CachingPipe.init_cache}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{init\_cache}}}{\emph{*args}, \emph{**kwargs}}{}
This should initialize a cache object called self.cache

\end{fulllineitems}

\index{check\_input() (Fireworks.toolbox.pipes.CachingPipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.pipes.CachingPipe.check_input}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_input}}}{}{}
Checks inputs to determine if they implement \_\_getitem\_\_.

\end{fulllineitems}

\index{compute\_length() (Fireworks.toolbox.pipes.CachingPipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.pipes.CachingPipe.compute_length}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_length}}}{}{}
Step forward as far as the inputs will allow and compute length.
Note: If the inputs are infinite, then this will go on forever.

\end{fulllineitems}


\end{fulllineitems}

\index{Title2LabelPipe (class in Fireworks.toolbox.pipes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.pipes.Title2LabelPipe}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.toolbox.pipes.}}\sphinxbfcode{\sphinxupquote{Title2LabelPipe}}}{\emph{title}, \emph{input}, \emph{*args}, \emph{labels\_column='labels'}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{Fireworks:Fireworks.core.pipe.HookedPassThroughPipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.core.pipe.HookedPassThroughPipe}}}}}

This Pipe takes one Pipe as input and inserts a column called ‘label’
containing the provided title of the input Pipe to to all outputs.
\index{insert\_labels() (Fireworks.toolbox.pipes.Title2LabelPipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.pipes.Title2LabelPipe.insert_labels}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{insert\_labels}}}{\emph{message}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{LabelerPipe (class in Fireworks.toolbox.pipes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.pipes.LabelerPipe}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.toolbox.pipes.}}\sphinxbfcode{\sphinxupquote{LabelerPipe}}}{\emph{input}, \emph{labels}, \emph{*args}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{Fireworks:Fireworks.core.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.core.pipe.Pipe}}}}}

This Pipe implements a to\_tensor function that converts labels contained in messages to tensors based on an internal labels dict.
\index{to\_tensor() (Fireworks.toolbox.pipes.LabelerPipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.pipes.LabelerPipe.to_tensor}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{to\_tensor}}}{\emph{batch}, \emph{labels\_column='labels'}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{RepeaterPipe (class in Fireworks.toolbox.pipes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.pipes.RepeaterPipe}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.toolbox.pipes.}}\sphinxbfcode{\sphinxupquote{RepeaterPipe}}}{\emph{input}, \emph{*args}, \emph{repetitions=10}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{Fireworks:Fireworks.core.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.core.pipe.Pipe}}}}}

Given an input Pipe that is iterable, enables repeat iteration.
\index{reset() (Fireworks.toolbox.pipes.RepeaterPipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.pipes.RepeaterPipe.reset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset}}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{ShufflerPipe (class in Fireworks.toolbox.pipes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.pipes.ShufflerPipe}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.toolbox.pipes.}}\sphinxbfcode{\sphinxupquote{ShufflerPipe}}}{\emph{input}, \emph{*args}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{Fireworks:Fireworks.core.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.core.pipe.Pipe}}}}}

Given input Pipes that implement \_\_getitem\_\_ and \_\_len\_\_, will shuffle the indices so that iterating through
the Pipe or calling \_\_getitem\_\_ will return different values.
\index{check\_input() (Fireworks.toolbox.pipes.ShufflerPipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.pipes.ShufflerPipe.check_input}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_input}}}{}{}
Check inputs to see if they implement \_\_getitem\_\_ and \_\_len\_\_

\end{fulllineitems}

\index{shuffle() (Fireworks.toolbox.pipes.ShufflerPipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.pipes.ShufflerPipe.shuffle}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{shuffle}}}{\emph{order=None}}{}
\end{fulllineitems}

\index{reset() (Fireworks.toolbox.pipes.ShufflerPipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.pipes.ShufflerPipe.reset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset}}}{}{}
Triggers a shuffle on reset.

\end{fulllineitems}


\end{fulllineitems}

\index{IndexMapperPipe (class in Fireworks.toolbox.pipes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.pipes.IndexMapperPipe}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.toolbox.pipes.}}\sphinxbfcode{\sphinxupquote{IndexMapperPipe}}}{\emph{input\_indices}, \emph{output\_indices}, \emph{*args}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{Fireworks:Fireworks.core.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.core.pipe.Pipe}}}}}

Given input Pipes that implement \_\_getitem\_\_, returns a Pipe that maps indices in input\_indices to output\_indices via \_\_getitem\_\_
\index{check\_input() (Fireworks.toolbox.pipes.IndexMapperPipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.pipes.IndexMapperPipe.check_input}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_input}}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{BatchingPipe (class in Fireworks.toolbox.pipes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.pipes.BatchingPipe}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.toolbox.pipes.}}\sphinxbfcode{\sphinxupquote{BatchingPipe}}}{\emph{*args}, \emph{batch\_size=5}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{Fireworks:Fireworks.core.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.core.pipe.Pipe}}}}}

Generates minibatches.
\index{reset() (Fireworks.toolbox.pipes.BatchingPipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.pipes.BatchingPipe.reset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset}}}{}{}
\end{fulllineitems}


\end{fulllineitems}



\subsection{Junctions}
\label{\detokenize{Fireworks:junctions}}
Whereas Pipes are designed to have one input, Junctions can have multiple inputs, called components. Since there is no unambiguous way to
define how recursive method calls would work in this situation, it is the responsibility of each Junction to have built-in logic for how to
aggregate its components in order to respond to method calls from downstream sources. This provides a way to construct more complex
computation graphs.

\phantomsection\label{\detokenize{Fireworks:module-Fireworks.core.junction}}\index{Fireworks.core.junction (module)}\index{Junction (class in Fireworks.core.junction)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.junction.Junction}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.core.junction.}}\sphinxbfcode{\sphinxupquote{Junction}}}{\emph{*args}, \emph{components=None}, \emph{**kwargs}}{}
Bases: \sphinxhref{https://docs.python.org/3/library/functions.html\#object}{\sphinxcode{\sphinxupquote{object}}}

A junction can take pipes as inputs, and its outputs can be piped to other pipes.
All communication is done via Message objects.

Unlike Pipes, junctions do not automatically have recursive method calling. This is because they have multiple input sources,
which would result in ambiguity. Instead, junctions are meant to act as bridges between multiple pipes in order to enable
complex workflows which require more than a linear pipeline.

\end{fulllineitems}

\phantomsection\label{\detokenize{Fireworks:module-Fireworks.toolbox.junctions}}\index{Fireworks.toolbox.junctions (module)}\index{HubJunction (class in Fireworks.toolbox.junctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.junctions.HubJunction}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.toolbox.junctions.}}\sphinxbfcode{\sphinxupquote{HubJunction}}}{\emph{*args}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{Fireworks:Fireworks.core.junction.Junction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.core.junction.Junction}}}}}

This junction takes multiple sources implementing \_\_next\_\_ as input and implements a new \_\_next\_\_ method that samples
its input sources.
\index{check\_inputs() (Fireworks.toolbox.junctions.HubJunction method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.junctions.HubJunction.check_inputs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_inputs}}}{}{}
\end{fulllineitems}

\index{reset() (Fireworks.toolbox.junctions.HubJunction method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.junctions.HubJunction.reset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset}}}{}{}
\end{fulllineitems}

\index{sample\_inputs() (Fireworks.toolbox.junctions.HubJunction method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.junctions.HubJunction.sample_inputs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sample\_inputs}}}{}{}
Returns the key associated with an input source that should be stepped through next.

\end{fulllineitems}


\end{fulllineitems}

\index{RandomHubJunction (class in Fireworks.toolbox.junctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.junctions.RandomHubJunction}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.toolbox.junctions.}}\sphinxbfcode{\sphinxupquote{RandomHubJunction}}}{\emph{*args}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{Fireworks:Fireworks.toolbox.junctions.HubJunction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.toolbox.junctions.HubJunction}}}}}

HubJunction that randomly chooses inputs to step through.
\index{sample\_inputs() (Fireworks.toolbox.junctions.RandomHubJunction method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.junctions.RandomHubJunction.sample_inputs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sample\_inputs}}}{}{}
Returns the key associated with an input source that should be stepped through next.

\end{fulllineitems}


\end{fulllineitems}

\index{ClockworkHubJunction (class in Fireworks.toolbox.junctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.junctions.ClockworkHubJunction}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.toolbox.junctions.}}\sphinxbfcode{\sphinxupquote{ClockworkHubJunction}}}{\emph{*args}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{Fireworks:Fireworks.toolbox.junctions.HubJunction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.toolbox.junctions.HubJunction}}}}}

HubJunction that iterates through input sources one at a time.
\index{reset() (Fireworks.toolbox.junctions.ClockworkHubJunction method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.junctions.ClockworkHubJunction.reset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset}}}{}{}
\end{fulllineitems}

\index{sample\_inputs() (Fireworks.toolbox.junctions.ClockworkHubJunction method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.junctions.ClockworkHubJunction.sample_inputs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sample\_inputs}}}{}{}
Loops through inputs until finding one that is available.

\end{fulllineitems}


\end{fulllineitems}

\index{SwitchJunction (class in Fireworks.toolbox.junctions)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.junctions.SwitchJunction}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.toolbox.junctions.}}\sphinxbfcode{\sphinxupquote{SwitchJunction}}}{\emph{*args}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{Fireworks:Fireworks.core.junction.Junction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.core.junction.Junction}}}}}

This junction has an internal switch that determines which of it’s components all method calls will be routed to.
\index{route (Fireworks.toolbox.junctions.SwitchJunction attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.junctions.SwitchJunction.route}}\pysigline{\sphinxbfcode{\sphinxupquote{route}}}
Returns the component to route method calls to based on the internal switch.

\end{fulllineitems}


\end{fulllineitems}



\subsection{Models}
\label{\detokenize{Fireworks:models}}
Models are a data structure for representing mathematical models that can be stacked together, incorporated into pipelines, and have their
parameters trained using PyTorch. These Models don’t have to be neural networks or even machine learning models; they can represent any
function that you want.
The goal of the Models class is to decouple the parameterization of a model from its computation. By doing this, those parameters can be
swapped in and out as needed, while the computation logic is contained in the code itself. This structure makes it easy to save and load models.
For example, if a Model computes y = m*x+b, the parameters m and b can be provided during initialization, they can be learned using gradient
descent, or loaded in from a database.
Models function like Junctions with respect to their parameters, which are called components. These components can be PyTorch Parameters,
PyTorch Modules, or some other object that has whatever methods/attributes the Model requires.
Models function like Pipes with respect to their arguments. Hence, you can insert a Model inside a Pipeline. Models also function like
PyTorch Modules with respect to computation and training. Hence, once you have created a Model, you can train it using a method like gradient
descent. PyTorch will keep track of gradients and Parameters inside your Models automatically. You can also freeze and unfreeze components
of a Model using the freeze/unfreeze methods.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{m} \PYG{o}{=} \PYG{n}{LinearModel}\PYG{p}{(}\PYG{n}{components}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{m}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Initialize model for y = m*x+b with m = 1.}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{m}\PYG{o}{.}\PYG{n}{required\PYGZus{}components}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} This will return [\PYGZsq{}m\PYGZsq{}, \PYGZsq{}b\PYGZsq{}]. A model can optionally have initialization logic for components not provided}
\PYG{c+c1}{\PYGZsh{} For example, the y\PYGZhy{}intercept b can have a default initialization if not provided here.}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{m}\PYG{o}{.}\PYG{n}{components}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} This should return a dict containing both m and b. The model should have initialized a y\PYGZhy{}intercept and automatically added that to it\PYGZsq{}s components dict.}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{NonlinearModel}\PYG{p}{(}\PYG{n+nb}{input}\PYG{o}{=}\PYG{n}{m}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Initialize a model that represents some nonlinearity and give it m as an input.}
\PYG{n}{result} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Evaluates f(m(x)) on argument message x. Because m is an input of f, m will be called first and pipe its output to f.}
\end{sphinxVerbatim}
\phantomsection\label{\detokenize{Fireworks:module-Fireworks.core.model}}\index{Fireworks.core.model (module)}\index{Model (class in Fireworks.core.model)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.model.Model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.core.model.}}\sphinxbfcode{\sphinxupquote{Model}}}{\emph{components=\{\}}, \emph{*args}, \emph{input=None}, \emph{skip\_module\_init=False}, \emph{**kwargs}}{}
Bases: \sphinxcode{\sphinxupquote{torch.nn.modules.module.Module}}, {\hyperref[\detokenize{Fireworks:Fireworks.core.pipe.HookedPassThroughPipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.core.pipe.HookedPassThroughPipe}}}}}, {\hyperref[\detokenize{Fireworks:Fireworks.core.junction.Junction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.core.junction.Junction}}}}}, \sphinxhref{https://docs.python.org/3/library/abc.html\#abc.ABC}{\sphinxcode{\sphinxupquote{abc.ABC}}}

Represents a statistical model which has a set of components, and a
means for converting inputs into outputs. The model functions like a Pipe
with respect to the input/output stream, and it functions like a Junction
with respect to the parameterization. components can be provided via multiple
different sources in this way, providing flexibility in model configuration.
Models can also provide components for other Models, enabling one to create
complex graphs of Models that can be trained simultaneously or individually.
\index{init\_default\_components() (Fireworks.core.model.Model method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.model.Model.init_default_components}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{init\_default\_components}}}{}{}
This method can optionally be implemented in order for the model to provide a default initialization for some or all of its
required components.

\end{fulllineitems}

\index{update\_components() (Fireworks.core.model.Model method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.model.Model.update_components}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update\_components}}}{\emph{components=None}}{}
\end{fulllineitems}

\index{check\_components() (Fireworks.core.model.Model method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.model.Model.check_components}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_components}}}{\emph{components=None}}{}
Checks to see if the provided components dict provides all necessary params for this model to run.

\end{fulllineitems}

\index{required\_components (Fireworks.core.model.Model attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.model.Model.required_components}}\pysigline{\sphinxbfcode{\sphinxupquote{required\_components}}}
This should be overridden by a subclass in order to specify components that should be provided during initialization. Otherwise,
this will default to just return the components already present within the Model.

\end{fulllineitems}

\index{forward() (Fireworks.core.model.Model method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.model.Model.forward}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{forward}}}{\emph{message}}{}
Represents a forward pass application of the model to an input. Must be implemented by a subclass.
This should return a Message.

\end{fulllineitems}

\index{freeze() (Fireworks.core.model.Model method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.model.Model.freeze}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{freeze}}}{\emph{components=None}}{}
Freezes the given components of the model (or all of them if none are specified) in order to prevent gradient updates.
This means setting requires\_grad to false for specified components so that these components
are not updated during training.

\end{fulllineitems}

\index{unfreeze() (Fireworks.core.model.Model method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.model.Model.unfreeze}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{unfreeze}}}{\emph{components=None}}{}
Unfreezes the given components of the model (or all of them if none are specified) in order to prevent gradient updates.
This means setting requires\_grad to true for specified components so that these components
are updated during training.

\end{fulllineitems}


\end{fulllineitems}

\index{freeze\_module() (in module Fireworks.core.model)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.model.freeze_module}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.core.model.}}\sphinxbfcode{\sphinxupquote{freeze\_module}}}{\emph{module}, \emph{parameters=None}, \emph{submodules=None}}{}
Recursively freezes the parameters in a PyTorch module.

\end{fulllineitems}

\index{unfreeze\_module() (in module Fireworks.core.model)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.model.unfreeze_module}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.core.model.}}\sphinxbfcode{\sphinxupquote{unfreeze\_module}}}{\emph{module}, \emph{parameters=None}, \emph{submodules=None}}{}
Recursively unfreezes the parameters in a PyTorch module.

\end{fulllineitems}

\index{model\_from\_module() (in module Fireworks.core.model)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.core.model.model_from_module}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.core.model.}}\sphinxbfcode{\sphinxupquote{model\_from\_module}}}{\emph{module\_class}}{}
Given the class definition for a pytorch module, returns a model that
encapsulates that module.

\end{fulllineitems}



\subsection{Database}
\label{\detokenize{Fireworks:database}}
This module contains methods and classes for ingesting and reading data to/from a database. A user can specify a schema and stream messages
from a source into a relational database. You can also create a source that streams data from a database based on a query. Because this
module is built using SQLalchemy, it inherits all of the capabilities of that library, such as the ability to interface with many different
relational databases and very precise control over schema and access.
There are two sources: A TableSource implements methods for writing a Message to a table, and a DBSource is an iterable that produces
Messages as it loops through a database query.

\sphinxstylestrong{TableSource}

A TableSource is initialized with an SQLalchemy table, and SQLalchemy engine, and an optional list of columns that the TableSource will write
to in the table. By specifying columns, you can choose to use only a subset of the columns in a table (for example, if there are
auto-incrementing ID columns that don’t need to explicitly written).
In addition to methods for standard relational database actions such as rollback, commit, etc., the TableSource has an insert method that
takes a Message object, converts it into a format that can be written to the database and then performs the insert. It also has a query
method that takes the same arguments that the query function in SQLalchemy takes (or does a SELECT * query by default) and returns a DBSource
object corresponding to that query.

\sphinxstylestrong{DBSource}

This Source is initialized with an SQLalchemy query and iterates through the results of that query. It converts the outputs to Messages as
it does so, enabling one to easily incorporate database queries into a Source pipeline.

\phantomsection\label{\detokenize{Fireworks:module-Fireworks.extensions.database}}\index{Fireworks.extensions.database (module)}\index{TablePipe (class in Fireworks.extensions.database)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.database.TablePipe}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.extensions.database.}}\sphinxbfcode{\sphinxupquote{TablePipe}}}{\emph{table}, \emph{engine}, \emph{columns=None}, \emph{input=None}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{Fireworks:Fireworks.core.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.core.pipe.Pipe}}}}}

Represents an SQLalchemy Table while having the functionality of a Pipe.
\index{init\_db() (Fireworks.extensions.database.TablePipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.database.TablePipe.init_db}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{init\_db}}}{}{}
Initializes metadata for internal table. This ensures that the table exists in the database.

\end{fulllineitems}

\index{commit() (Fireworks.extensions.database.TablePipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.database.TablePipe.commit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{commit}}}{}{}
Commits transactions to database.

\end{fulllineitems}

\index{rollback() (Fireworks.extensions.database.TablePipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.database.TablePipe.rollback}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{rollback}}}{}{}
Rollbacks transactions in current session that haven’t been committed yet.

\end{fulllineitems}

\index{insert() (Fireworks.extensions.database.TablePipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.database.TablePipe.insert}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{insert}}}{\emph{batch}}{}
Inserts the contents of batch message into the database using self.table object
NOTE: Only the dataframe components of a message will be inserted.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{batch}} ({\hyperref[\detokenize{Fireworks:Fireworks.core.message.Message}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Message}}}}}) \textendash{} A message to be inserted. The columns and types must be consistent with the database schema.

\end{description}\end{quote}

\end{fulllineitems}

\index{query() (Fireworks.extensions.database.TablePipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.database.TablePipe.query}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{query}}}{\emph{entities=None}, \emph{*args}, \emph{**kwargs}}{}
Queries the database and generates a DBPipe corresponding to the result.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{entities}} \textendash{} A list of column names

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{args}} \textendash{} Optional positional arguments for the SQLalchemy query function

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} \textendash{} Optional keyword arguments for the SQLalchemy query function

\end{itemize}

\item[{Returns}] \leavevmode
A DBPipe object that can iterate through the results of the query.

\item[{Return type}] \leavevmode
dbpipe ({\hyperref[\detokenize{Fireworks:Fireworks.extensions.database.DBPipe}]{\sphinxcrossref{DBPipe}}})

\end{description}\end{quote}

\end{fulllineitems}

\index{delete() (Fireworks.extensions.database.TablePipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.database.TablePipe.delete}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{delete}}}{\emph{column\_name}, \emph{values}}{}
\end{fulllineitems}

\index{update() (Fireworks.extensions.database.TablePipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.database.TablePipe.update}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update}}}{\emph{filter\_column}, \emph{batch}}{}
\end{fulllineitems}

\index{upsert() (Fireworks.extensions.database.TablePipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.database.TablePipe.upsert}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{upsert}}}{\emph{batch}}{}
Performs an upsert into the database. This is equivalent to performing an update + insert (ie. if value is not present, insert it,
otherwise update the existing value.)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{batch}} ({\hyperref[\detokenize{Fireworks:Fireworks.core.message.Message}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Message}}}}}) \textendash{} The message to upsert.

\end{description}\end{quote}

\end{fulllineitems}

\index{make\_row() (Fireworks.extensions.database.TablePipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.database.TablePipe.make_row}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{make\_row}}}{\emph{row}}{}
Converts a Message or dict mapping columns to values into a table object that can be inserted into an SQLalchemy database.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{row}} \textendash{} row in Message or dict form to convert.

\item[{Returns}] \leavevmode
row converted to table form.

\item[{Return type}] \leavevmode
table

\end{description}\end{quote}

\end{fulllineitems}

\index{make\_row\_dict() (Fireworks.extensions.database.TablePipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.database.TablePipe.make_row_dict}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{make\_row\_dict}}}{\emph{row}}{}
Converts a 1-row Message into a dict of atomic (non-listlike) elements. This can be used for the bulk\_insert\_mappings method of
an SQLalchemy session, which skips table instantiation and takes dictionaries as arguments instead.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{row}} \textendash{} row in Message or dict form to convert.

\item[{Returns}] \leavevmode
row converted to table form.

\item[{Return type}] \leavevmode
table

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{create\_table() (in module Fireworks.extensions.database)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.database.create_table}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.extensions.database.}}\sphinxbfcode{\sphinxupquote{create\_table}}}{\emph{name}, \emph{columns}, \emph{primary\_key=None}, \emph{Base=None}}{}
Creates a table given a dict of column names to data types. This is an easy
way to quickly create a schema for a data pipeline.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{columns}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#dict}{\sphinxstyleliteralemphasis{\sphinxupquote{dict}}}) \textendash{} Dict mapping column names to SQLalchemy types.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{primary\_key}} \textendash{} The column that should be the primary key of the table. If unspecified, a new auto-incrementing column called ‘id’
will be added as the primary key. SQLalchemy requires that all tables have a primary key, and this ensures that every row
is always uniquely identifiable.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Base}} \textendash{} An optional argument that can be provided to specify the Base class that the new table class will inherit from. By
default, this will be set to an instance of declarative\_base from SQLalchemy.

\end{itemize}

\item[{Returns}] \leavevmode
A table class specifying the schema for the database table.

\item[{Return type}] \leavevmode
simpletable (sqlalchemy.ext.declarative.api.DeclarativeMeta)

\end{description}\end{quote}

\end{fulllineitems}

\index{DBPipe (class in Fireworks.extensions.database)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.database.DBPipe}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.extensions.database.}}\sphinxbfcode{\sphinxupquote{DBPipe}}}{\emph{table}, \emph{engine}, \emph{query=None}, \emph{columns\_and\_types=None}}{}
Bases: {\hyperref[\detokenize{Fireworks:Fireworks.core.pipe.Pipe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.core.pipe.Pipe}}}}}

Pipe that can iterate through the output of a database query.
\index{reset() (Fireworks.extensions.database.DBPipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.database.DBPipe.reset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset}}}{\emph{entities=None}, \emph{*args}, \emph{**kwargs}}{}
Resets DBPipe by reperforming the query, so that it is now at the beginning of the query.

\end{fulllineitems}

\index{filter() (Fireworks.extensions.database.DBPipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.database.DBPipe.filter}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{filter}}}{\emph{column\_name}, \emph{predicate}, \emph{*args}, \emph{**kwargs}}{}
Applies an sqlalchemy filter to query.

\end{fulllineitems}

\index{all() (Fireworks.extensions.database.DBPipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.database.DBPipe.all}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{all}}}{}{}
Returns the results of the query as a single Message object.

\end{fulllineitems}

\index{delete() (Fireworks.extensions.database.DBPipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.database.DBPipe.delete}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{delete}}}{}{}
\end{fulllineitems}

\index{update() (Fireworks.extensions.database.DBPipe method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.database.DBPipe.update}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update}}}{\emph{batch}}{}
Updates the contents of this DBPipe by replacing them with batch
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{batch}} \textendash{} A Message

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{parse\_columns() (in module Fireworks.extensions.database)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.database.parse_columns}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.extensions.database.}}\sphinxbfcode{\sphinxupquote{parse\_columns}}}{\emph{object}, \emph{ignore\_id=True}}{}
Returns the names of columns in a table or query object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{table}} (\sphinxstyleliteralemphasis{\sphinxupquote{sqlalchemy.ext.declarative.api.DeclarativeMeta}}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ignore\_id}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#bool}{\sphinxstyleliteralemphasis{\sphinxupquote{bool}}}) \textendash{} If True, ignore the ‘id’ column, which is a default primary key
added by the create\_table function.

\end{itemize}

\item[{Returns}] \leavevmode
A list of columns names in the sqlalchemy object.

\item[{Return type}] \leavevmode
columns (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#list}{list})

\end{description}\end{quote}

\end{fulllineitems}

\index{parse\_columns\_and\_types() (in module Fireworks.extensions.database)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.database.parse_columns_and_types}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.extensions.database.}}\sphinxbfcode{\sphinxupquote{parse\_columns\_and\_types}}}{\emph{object}, \emph{ignore\_id=True}}{}
Returns column names and types in a object or query object as a dict
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{object}} \textendash{} An SQLalchemy table or Query object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ignore\_id}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#bool}{\sphinxstyleliteralemphasis{\sphinxupquote{bool}}}) \textendash{} If True, ignore the ‘id’ column, which is a default primary key
added by the create\_table function.

\end{itemize}

\item[{Returns}] \leavevmode
A dict mapping column names to their SQLalchemy type.

\item[{Return type}] \leavevmode
columns\_and\_types (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#dict}{dict})

\end{description}\end{quote}

\end{fulllineitems}

\index{convert() (in module Fireworks.extensions.database)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.database.convert}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.extensions.database.}}\sphinxbfcode{\sphinxupquote{convert}}}{\emph{value}, \emph{sqltype}}{}
Converts a given value to a value that SQLalchemy can read.

\end{fulllineitems}

\index{to\_message() (in module Fireworks.extensions.database)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.database.to_message}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.extensions.database.}}\sphinxbfcode{\sphinxupquote{to\_message}}}{\emph{row}, \emph{columns\_and\_types=None}}{}
Converts a database query result produced by SQLalchemy into a Message
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{row}} \textendash{} A row from the query.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{columns\_and\_types}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#dict}{\sphinxstyleliteralemphasis{\sphinxupquote{dict}}}) \textendash{} If unspecified, this will be inferred. Otherwise,
you can specify the columns
to parse, for example, if you only want to extract some columns.

\end{itemize}

\item[{Returns}] \leavevmode
Message representation of input.

\item[{Return type}] \leavevmode
message

\end{description}\end{quote}

\end{fulllineitems}

\index{cast() (in module Fireworks.extensions.database)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.database.cast}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.extensions.database.}}\sphinxbfcode{\sphinxupquote{cast}}}{\emph{value}}{}
Converts values to basic types (ie. np.int64 to int)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{value}} \textendash{} The object to be cast.

\item[{Returns}] \leavevmode
The cast object.

\end{description}\end{quote}

\end{fulllineitems}

\index{reflect\_table() (in module Fireworks.extensions.database)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.database.reflect_table}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.extensions.database.}}\sphinxbfcode{\sphinxupquote{reflect\_table}}}{\emph{table\_name}, \emph{engine}}{}
Gets the table with the given name from the sqlalchemy engine.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{table\_name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} Name of the table to extract.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{engine}} (\sphinxstyleliteralemphasis{\sphinxupquote{sqlalchemy.engine.base.Engine}}) \textendash{} Engine to extract from.

\end{itemize}

\item[{Returns}] \leavevmode
The extracted table, which can be now be used to read from the database.

\item[{Return type}] \leavevmode
table (sqlalchemy.ext.declarative.api.DeclarativeMeta)

\end{description}\end{quote}

\end{fulllineitems}



\subsection{Experiment}
\label{\detokenize{Fireworks:experiment}}
The Experiment module offers a way to save data from individual runs of a model. This makes it convenient to compare results from different
experiments and to replicate those experiments.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{exp} \PYG{o}{=} \PYG{n}{Experiment}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{db\PYGZus{}path}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{description}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

will create a folder named db\_path/name containing a sqlite file called name.sqlite. You can now save any objects to that folder using

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{with} \PYG{n}{exp}\PYG{o}{.}\PYG{n}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{filename}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
    \PYG{n}{f}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}
\end{sphinxVerbatim}

This will create a file handle f to the desired filename in the folder. You can also use exp.get\_engine(‘name’) or exp.get\_session(‘name’)
to get an SQLalchemy session/engine object with the given name that you can then use to save/load data. Combined with Fireworks.db, you can
save any data in Message format relatively easily.

\phantomsection\label{\detokenize{Fireworks:module-Fireworks.extensions.experiment}}\index{Fireworks.extensions.experiment (module)}\index{load\_experiment() (in module Fireworks.extensions.experiment)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.experiment.load_experiment}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.extensions.experiment.}}\sphinxbfcode{\sphinxupquote{load\_experiment}}}{\emph{experiment\_path}}{}
Returns an experiment object corresponding to the database in the given path.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{experiment\_path}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} Path to the experiment folder.

\item[{Returns}] \leavevmode
An Experiment object loaded using the files in the given folder path.

\item[{Return type}] \leavevmode
experiment ({\hyperref[\detokenize{Fireworks:Fireworks.extensions.experiment.Experiment}]{\sphinxcrossref{Experiment}}})

\end{description}\end{quote}

\end{fulllineitems}

\index{Experiment (class in Fireworks.extensions.experiment)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.experiment.Experiment}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.extensions.experiment.}}\sphinxbfcode{\sphinxupquote{Experiment}}}{\emph{experiment\_name}, \emph{db\_path}, \emph{description=None}, \emph{load=False}}{}
Bases: \sphinxhref{https://docs.python.org/3/library/functions.html\#object}{\sphinxcode{\sphinxupquote{object}}}
\index{load\_experiment() (Fireworks.extensions.experiment.Experiment method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.experiment.Experiment.load_experiment}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{load\_experiment}}}{\emph{path=None}, \emph{experiment\_name=None}}{}
Loads in parameters associated with this experiment from a directory.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{path}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} Path to the experiment folder.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{experiment\_name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} Name to set this experiment to.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_dir() (Fireworks.extensions.experiment.Experiment method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.experiment.Experiment.create_dir}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_dir}}}{}{}
Creates a folder in db\_path directory corresponding to this Experiment.

\end{fulllineitems}

\index{load\_metadata() (Fireworks.extensions.experiment.Experiment method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.experiment.Experiment.load_metadata}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{load\_metadata}}}{}{}
Loads metadata from experiment folder by reading the metadata table.

\end{fulllineitems}

\index{init\_metadata() (Fireworks.extensions.experiment.Experiment method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.experiment.Experiment.init_metadata}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{init\_metadata}}}{}{}
Initializes metadata table. This is a necessary action whenever using an SQLalchemy table for the first time and is idempotent,
so calling this method multiple times does not produce side-effects.

\end{fulllineitems}

\index{get\_engine() (Fireworks.extensions.experiment.Experiment method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.experiment.Experiment.get_engine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_engine}}}{\emph{name}}{}
Creates an engine corresponding to a database with the given name. In particular, this creates a file called \{name\}.sqlite
in this experiment’s save directory, and makes an engine to connect to it.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{name}} \textendash{} Name of engine to create. This will also be the name of the file that is created.

\item[{Returns}] \leavevmode
The new engine. You can also reach this engine now by calling self.engines{[}name{]}

\item[{Return type}] \leavevmode
engine

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_session() (Fireworks.extensions.experiment.Experiment method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.experiment.Experiment.get_session}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_session}}}{\emph{name}}{}
Creates an SQLalchemy session corresponding to the engine with the given name that can be used to interact with the database.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{name}} \textendash{} Name of engine corresponding to session. The engine will be created if one with that name does not already exist.

\item[{Returns}] \leavevmode
A session created from the chosen engine.

\item[{Return type}] \leavevmode
session

\end{description}\end{quote}

\end{fulllineitems}

\index{open() (Fireworks.extensions.experiment.Experiment method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.experiment.Experiment.open}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{open}}}{\emph{filename}, \emph{*args}, \emph{string\_only=False}}{}
Returns a handle to a file with the given filename inside this experiment’s directory.
If string\_only is true, then this instead returns a string with the path to create the file.
If the a file with ‘filename’ is already present in the directory, this will raise an error.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} Name of file.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{args}} \textendash{} Additional positional args for the open function.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{string\_only}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#bool}{\sphinxstyleliteralemphasis{\sphinxupquote{bool}}}) \textendash{} If true, will return the path to the file rather than the file handle. This can be useful if you want to
create the file using some other library.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{description}
\item[{If string\_only is True, the path to the file. Otherwise, the opened file handle. Note: You can use this method in a}] \leavevmode
with statement to auto-close the file.

\end{description}


\item[{Return type}] \leavevmode
file

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{filter\_columns() (in module Fireworks.extensions.experiment)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.experiment.filter_columns}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.extensions.experiment.}}\sphinxbfcode{\sphinxupquote{filter\_columns}}}{\emph{message}, \emph{columns=None}}{}
Returns only the given columns of message or everything if columns is None.
If tensor columns are requested, they are converted to ndarray first.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{columns}} \textendash{} Columns to keep. Default = None, meaning return the Message as is.

\item[{Returns}] \leavevmode
Message with the filetered columns.

\item[{Return type}] \leavevmode
message

\end{description}\end{quote}

\end{fulllineitems}



\subsection{Factory}
\label{\detokenize{Fireworks:factory}}
The Factory module contains a class with the same name that performs hyperparameter optimization by repeatedly spawning independent instances
of a model, training and evaluating them, and recording their parameters. The design of this module is based off of a ‘blackboard architecture’
in software engineering, in which multiple independent processes can read and write from a shared pool of information, the blackboard. In this
case, the shared pool of information is the hyperparameters and their corresponding evaluation metrics. The factory class is able to use that
information to choose new hyperparameters (based on a user supplied search algorithm) and repeat this process until a trigger to stop is raised.
\begin{description}
\item[{A factory class takes four arguments:}] \leavevmode\begin{itemize}
\item {} 
Trainer - A function that takes a dictionary of hyperparameters,  trains a model and returns the trained model

\item {} 
Metrics\_dict - A dictionary of objects that compute metrics during model training or evaluation.

\item {} 
Generator - A function that takes the computed metrics and parameters up to this point as arguments and generates a new set of metrics to

\end{itemize}

use for training. The generator represents the search strategy that you are using.
- Eval\_dataloader - A dataloader (an iterable that produces minibatches as Message objects) that represents the evaluation dataset.

\end{description}

After instantiated with these arguments and calling the run method, the factory will use its generator to generate hyperparameters, train
models using those hyperparameters, and compute metrics by evaluating those models against the eval\_dataloader. This will loop until something
raises a StopHyperparameterOptimization flag.

Different subclasses of Factory have different means for storing metrics and parameters. The LocalMemoryFactory stores them in memory as the
name implies. The SQLFactory stores them in a relational database table. Because of this, SQLFactory takes three additional initialization arguments:
\begin{itemize}
\item {} 
Params\_table - An SQLalchemy table specifying the schema for storing parameters.

\item {} 
Metrics\_table - An SQLalchemy table specifying the schema for storing metrics.

\item {} 
Engine - An SQLalchemy engine, representing the database connection.

\end{itemize}

Additionally, to reduce memory and network bandwidth usage, the SQLFactory table caches information in local memory while regularly syncing
with the database.

Currently, all of these steps take place on a single thread, but in the future we will be able to automatically parallelize and distribute them.

\phantomsection\label{\detokenize{Fireworks:module-Fireworks.extensions.factory}}\index{Fireworks.extensions.factory (module)}\index{Factory (class in Fireworks.extensions.factory)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.factory.Factory}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.extensions.factory.}}\sphinxbfcode{\sphinxupquote{Factory}}}{\emph{trainer}, \emph{metrics\_dict}, \emph{generator}, \emph{eval\_dataloader}, \emph{*args}, \emph{**kwargs}}{}
Bases: \sphinxhref{https://docs.python.org/3/library/functions.html\#object}{\sphinxcode{\sphinxupquote{object}}}

Base class for parallel hyperparameter optimization in pytorch using queues.
\index{get\_connection() (Fireworks.extensions.factory.Factory method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.factory.Factory.get_connection}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_connection}}}{}{}
\end{fulllineitems}

\index{run() (Fireworks.extensions.factory.Factory method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.factory.Factory.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{}{}
\end{fulllineitems}

\index{read() (Fireworks.extensions.factory.Factory method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.factory.Factory.read}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{read}}}{}{}
\end{fulllineitems}

\index{write() (Fireworks.extensions.factory.Factory method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.factory.Factory.write}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{write}}}{\emph{params}, \emph{metrics\_dict}}{}
\end{fulllineitems}

\index{after() (Fireworks.extensions.factory.Factory method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.factory.Factory.after}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{after}}}{\emph{*args}, \emph{**kwargs}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{LocalMemoryFactory (class in Fireworks.extensions.factory)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.factory.LocalMemoryFactory}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.extensions.factory.}}\sphinxbfcode{\sphinxupquote{LocalMemoryFactory}}}{\emph{trainer}, \emph{metrics\_dict}, \emph{generator}, \emph{eval\_dataloader}, \emph{*args}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{Fireworks:Fireworks.extensions.factory.Factory}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.extensions.factory.Factory}}}}}

Factory that stores parameters in memory.
\index{get\_connection() (Fireworks.extensions.factory.LocalMemoryFactory method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.factory.LocalMemoryFactory.get_connection}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_connection}}}{}{}
\end{fulllineitems}

\index{read() (Fireworks.extensions.factory.LocalMemoryFactory method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.factory.LocalMemoryFactory.read}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{read}}}{}{}
\end{fulllineitems}

\index{write() (Fireworks.extensions.factory.LocalMemoryFactory method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.factory.LocalMemoryFactory.write}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{write}}}{\emph{params}, \emph{metrics\_dict}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{SQLFactory (class in Fireworks.extensions.factory)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.factory.SQLFactory}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.extensions.factory.}}\sphinxbfcode{\sphinxupquote{SQLFactory}}}{\emph{*args}, \emph{params\_table}, \emph{metrics\_tables}, \emph{engine}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{Fireworks:Fireworks.extensions.factory.Factory}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.extensions.factory.Factory}}}}}

Factory that stores parameters in SQLalchemy database while caching them locally.
\index{get\_connection() (Fireworks.extensions.factory.SQLFactory method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.factory.SQLFactory.get_connection}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_connection}}}{}{}
\end{fulllineitems}

\index{write() (Fireworks.extensions.factory.SQLFactory method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.factory.SQLFactory.write}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{write}}}{\emph{params}, \emph{metrics}}{}
\end{fulllineitems}

\index{read() (Fireworks.extensions.factory.SQLFactory method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.factory.SQLFactory.read}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{read}}}{}{}
\end{fulllineitems}

\index{read\_db() (Fireworks.extensions.factory.SQLFactory method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.factory.SQLFactory.read_db}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{read\_db}}}{}{}
\end{fulllineitems}

\index{sync() (Fireworks.extensions.factory.SQLFactory method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.factory.SQLFactory.sync}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sync}}}{}{}
Syncs local copy of metrics and params with db.

\end{fulllineitems}

\index{after() (Fireworks.extensions.factory.SQLFactory method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.extensions.factory.SQLFactory.after}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{after}}}{}{}
\end{fulllineitems}


\end{fulllineitems}



\subsection{Miscellaneous}
\label{\detokenize{Fireworks:module-Fireworks.toolbox.text}}\label{\detokenize{Fireworks:miscellaneous}}\index{Fireworks.toolbox.text (module)}\index{character\_tokenizer() (in module Fireworks.toolbox.text)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.text.character_tokenizer}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.toolbox.text.}}\sphinxbfcode{\sphinxupquote{character\_tokenizer}}}{\emph{sequence}}{}
Splits sequence into a list of characters.

\end{fulllineitems}

\index{space\_tokenizer() (in module Fireworks.toolbox.text)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.text.space_tokenizer}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.toolbox.text.}}\sphinxbfcode{\sphinxupquote{space\_tokenizer}}}{\emph{sequence}}{}
Splits sequence based on spaces.

\end{fulllineitems}

\index{pad\_sequence() (in module Fireworks.toolbox.text)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.text.pad_sequence}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.toolbox.text.}}\sphinxbfcode{\sphinxupquote{pad\_sequence}}}{\emph{sequence}, \emph{max\_length}, \emph{embeddings\_dict}, \emph{pad\_token='EOS'}}{}
Adds EOS tokens until sequence length is max\_length.

\end{fulllineitems}

\index{pad() (in module Fireworks.toolbox.text)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.text.pad}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.toolbox.text.}}\sphinxbfcode{\sphinxupquote{pad}}}{\emph{batch}, \emph{embeddings\_dict}, \emph{pad\_token='EOS'}}{}
Pads all embeddings in a batch to be the same length.

\end{fulllineitems}

\index{apply\_embeddings() (in module Fireworks.toolbox.text)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.text.apply_embeddings}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.toolbox.text.}}\sphinxbfcode{\sphinxupquote{apply\_embeddings}}}{\emph{sequence}, \emph{embeddings\_dict}, \emph{tokenizer}}{}
Decomposes sequence into tokens using tokenizer and then converts tokens to embeddings using embeddings\_dict.

\end{fulllineitems}

\index{create\_pretrained\_embeddings() (in module Fireworks.toolbox.text)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.text.create_pretrained_embeddings}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.toolbox.text.}}\sphinxbfcode{\sphinxupquote{create\_pretrained\_embeddings}}}{\emph{embeddings\_file}}{}
Loads embeddings vectors from file into a dict.

\end{fulllineitems}

\index{load\_embeddings() (in module Fireworks.toolbox.text)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.text.load_embeddings}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.toolbox.text.}}\sphinxbfcode{\sphinxupquote{load\_embeddings}}}{\emph{name='glove840b'}}{}
Loads serialized embeddings from pickle.

\end{fulllineitems}

\index{make\_vocabulary() (in module Fireworks.toolbox.text)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.text.make_vocabulary}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.toolbox.text.}}\sphinxbfcode{\sphinxupquote{make\_vocabulary}}}{\emph{text}, \emph{tokenizer=None}, \emph{cutoff\_rule=None}}{}
Converts an iterable of phrases into the set of unique tokens that are in the vocabulary.

\end{fulllineitems}

\index{make\_indices() (in module Fireworks.toolbox.text)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.text.make_indices}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.toolbox.text.}}\sphinxbfcode{\sphinxupquote{make\_indices}}}{\emph{vocabulary}}{}
Constructs a dictionary of token names to indices from a vocabulary.
Each index value corresponds to a one-hot vector.

\end{fulllineitems}

\index{too\_big() (in module Fireworks.toolbox.text)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.text.too_big}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.toolbox.text.}}\sphinxbfcode{\sphinxupquote{too\_big}}}{\emph{dataset}, \emph{start}, \emph{end}, \emph{dim=300}, \emph{cutoff=620000}}{}
Calculates if a batch consisting of dataset{[}start:end{]} is too big based on cutoff.

\end{fulllineitems}

\phantomsection\label{\detokenize{Fireworks:module-Fireworks.utils.utils}}\index{Fireworks.utils.utils (module)}\index{one\_hot (in module Fireworks.utils.utils)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.utils.utils.one_hot}}\pysigline{\sphinxcode{\sphinxupquote{Fireworks.utils.utils.}}\sphinxbfcode{\sphinxupquote{one\_hot}}}
\end{fulllineitems}

\index{index\_to\_list() (in module Fireworks.utils.utils)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.utils.utils.index_to_list}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.utils.utils.}}\sphinxbfcode{\sphinxupquote{index\_to\_list}}}{\emph{index}}{}
Converts an index to a list.

\end{fulllineitems}

\index{slice\_to\_list() (in module Fireworks.utils.utils)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.utils.utils.slice_to_list}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.utils.utils.}}\sphinxbfcode{\sphinxupquote{slice\_to\_list}}}{\emph{s}}{}
Converts a slice object to a list of indices

\end{fulllineitems}

\index{get\_indices() (in module Fireworks.utils.utils)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.utils.utils.get_indices}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.utils.utils.}}\sphinxbfcode{\sphinxupquote{get\_indices}}}{\emph{values}, \emph{listlike}}{}
Returns the indices in litlike that match elements in values

\end{fulllineitems}

\index{slice\_length() (in module Fireworks.utils.utils)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.utils.utils.slice_length}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.utils.utils.}}\sphinxbfcode{\sphinxupquote{slice\_length}}}{\emph{orange}}{}
Returns the length of the index corresponding to a slice.
For example, slice(0,4,2) has a length of two.

\end{fulllineitems}

\phantomsection\label{\detokenize{Fireworks:module-Fireworks.toolbox.preprocessing}}\index{Fireworks.toolbox.preprocessing (module)}\index{train\_test\_split() (in module Fireworks.toolbox.preprocessing)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.preprocessing.train_test_split}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.toolbox.preprocessing.}}\sphinxbfcode{\sphinxupquote{train\_test\_split}}}{\emph{pipe}, \emph{test=0.2}}{}
Splits input pipe into a training pipe and a test pipe.

\end{fulllineitems}

\index{oversample() (in module Fireworks.toolbox.preprocessing)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.preprocessing.oversample}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.toolbox.preprocessing.}}\sphinxbfcode{\sphinxupquote{oversample}}}{}{}
\end{fulllineitems}

\index{apply\_noise() (in module Fireworks.toolbox.preprocessing)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.preprocessing.apply_noise}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.toolbox.preprocessing.}}\sphinxbfcode{\sphinxupquote{apply\_noise}}}{}{}
\end{fulllineitems}

\index{Normalizer (class in Fireworks.toolbox.preprocessing)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.preprocessing.Normalizer}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Fireworks.toolbox.preprocessing.}}\sphinxbfcode{\sphinxupquote{Normalizer}}}{\emph{components=\{\}}, \emph{*args}, \emph{input=None}, \emph{skip\_module\_init=False}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{Fireworks:Fireworks.core.model.Model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fireworks.core.model.Model}}}}}

Normalizes Data by Mean and Variance. Analogous to sklearn.preprocessing.Normalizer
\index{required\_components (Fireworks.toolbox.preprocessing.Normalizer attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.preprocessing.Normalizer.required_components}}\pysigline{\sphinxbfcode{\sphinxupquote{required\_components}}\sphinxbfcode{\sphinxupquote{ = {[}'mean', 'variance'{]}}}}
\end{fulllineitems}

\index{init\_default\_components() (Fireworks.toolbox.preprocessing.Normalizer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.preprocessing.Normalizer.init_default_components}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{init\_default\_components}}}{}{}
This method can optionally be implemented in order for the model to provide a default initialization for some or all of its
required components.

\end{fulllineitems}

\index{forward() (Fireworks.toolbox.preprocessing.Normalizer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.preprocessing.Normalizer.forward}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{forward}}}{\emph{batch}}{}
Uses computed means and variances in order to transform the given batch.

\end{fulllineitems}

\index{fit() (Fireworks.toolbox.preprocessing.Normalizer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.preprocessing.Normalizer.fit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fit}}}{\emph{dataset=None}, \emph{continuamos=False}}{}
\end{fulllineitems}

\index{reset() (Fireworks.toolbox.preprocessing.Normalizer method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.toolbox.preprocessing.Normalizer.reset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset}}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{\detokenize{Fireworks:module-Fireworks.utils.events}}\index{Fireworks.utils.events (module)}\index{visdom\_loss\_handler() (in module Fireworks.utils.events)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.utils.events.visdom_loss_handler}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Fireworks.utils.events.}}\sphinxbfcode{\sphinxupquote{visdom\_loss\_handler}}}{\emph{modules\_dict}, \emph{model\_name}}{}
Attaches plots and metrics to trainer.

\end{fulllineitems}

\phantomsection\label{\detokenize{Fireworks:module-Fireworks.utils.exceptions}}\index{Fireworks.utils.exceptions (module)}\index{EndHyperparameterOptimization}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.utils.exceptions.EndHyperparameterOptimization}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{Fireworks.utils.exceptions.}}\sphinxbfcode{\sphinxupquote{EndHyperparameterOptimization}}}
Bases: \sphinxhref{https://docs.python.org/3/library/exceptions.html\#RuntimeError}{\sphinxcode{\sphinxupquote{RuntimeError}}}

This exception can be raised to signal a factory to stop looping.

\end{fulllineitems}

\index{ParameterizationError}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Fireworks:Fireworks.utils.exceptions.ParameterizationError}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{Fireworks.utils.exceptions.}}\sphinxbfcode{\sphinxupquote{ParameterizationError}}}
Bases: \sphinxhref{https://docs.python.org/3/library/exceptions.html\#KeyError}{\sphinxcode{\sphinxupquote{KeyError}}}

This exception is raised to indicate that a Model is missing required parameters that it needs to function.

\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{f}
\item\relax\sphinxstyleindexentry{Fireworks}\sphinxstyleindexpageref{Fireworks:\detokenize{module-Fireworks}}
\item\relax\sphinxstyleindexentry{Fireworks.core.cache}\sphinxstyleindexpageref{Fireworks:\detokenize{module-Fireworks.core.cache}}
\item\relax\sphinxstyleindexentry{Fireworks.core.junction}\sphinxstyleindexpageref{Fireworks:\detokenize{module-Fireworks.core.junction}}
\item\relax\sphinxstyleindexentry{Fireworks.core.message}\sphinxstyleindexpageref{Fireworks:\detokenize{module-Fireworks.core.message}}
\item\relax\sphinxstyleindexentry{Fireworks.core.model}\sphinxstyleindexpageref{Fireworks:\detokenize{module-Fireworks.core.model}}
\item\relax\sphinxstyleindexentry{Fireworks.core.pipe}\sphinxstyleindexpageref{Fireworks:\detokenize{module-Fireworks.core.pipe}}
\item\relax\sphinxstyleindexentry{Fireworks.extensions.database}\sphinxstyleindexpageref{Fireworks:\detokenize{module-Fireworks.extensions.database}}
\item\relax\sphinxstyleindexentry{Fireworks.extensions.experiment}\sphinxstyleindexpageref{Fireworks:\detokenize{module-Fireworks.extensions.experiment}}
\item\relax\sphinxstyleindexentry{Fireworks.extensions.factory}\sphinxstyleindexpageref{Fireworks:\detokenize{module-Fireworks.extensions.factory}}
\item\relax\sphinxstyleindexentry{Fireworks.toolbox.junctions}\sphinxstyleindexpageref{Fireworks:\detokenize{module-Fireworks.toolbox.junctions}}
\item\relax\sphinxstyleindexentry{Fireworks.toolbox.pipes}\sphinxstyleindexpageref{Fireworks:\detokenize{module-Fireworks.toolbox.pipes}}
\item\relax\sphinxstyleindexentry{Fireworks.toolbox.preprocessing}\sphinxstyleindexpageref{Fireworks:\detokenize{module-Fireworks.toolbox.preprocessing}}
\item\relax\sphinxstyleindexentry{Fireworks.toolbox.text}\sphinxstyleindexpageref{Fireworks:\detokenize{module-Fireworks.toolbox.text}}
\item\relax\sphinxstyleindexentry{Fireworks.utils.events}\sphinxstyleindexpageref{Fireworks:\detokenize{module-Fireworks.utils.events}}
\item\relax\sphinxstyleindexentry{Fireworks.utils.exceptions}\sphinxstyleindexpageref{Fireworks:\detokenize{module-Fireworks.utils.exceptions}}
\item\relax\sphinxstyleindexentry{Fireworks.utils.utils}\sphinxstyleindexpageref{Fireworks:\detokenize{module-Fireworks.utils.utils}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}